<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mubarak Afolabi — Articles</title>
    <link href="css/style.css" rel="stylesheet" />

    <style>
        /* Ensure all navbar icons are 32×32 */
        #site-navbar ul li img {
            width: 32px;
            height: 32px;
        }

        /* Make every nav link area clickable and show pointer */
        #site-navbar ul li a {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-decoration: none;
            color: white; /* Ensure text color is white as in index.html */
            cursor: pointer;
        }

        /* Mobile-specific Navbar Styles (Copied from index.html) */
        @media (max-width: 768px) {
            #site-navbar ul li img {
                width: 24px; /* Smaller icon size for mobile */
                height: 24px;
            }

            #site-navbar ul li a {
                font-size: 0.75rem; /* Smaller font size for labels */
            }

            #site-navbar ul {
                padding: 0.5rem 0; /* Adjust overall padding if needed */
                gap: 0.5rem; /* Add gap between each nav item */
            }
        }

        /* Existing styles from projects page for general layout and article cards */
        .thin-line {
            height: 0.5px;
            background-color: rgba(255, 255, 255, 0.5);
        }

        /* Styles specific to articles for stacking effect */
        .article-item {
            position: sticky;
            top: 60px; 
            z-index: 1;
            transition: opacity 0.3s ease-out;
            min-height: calc(100vh - 60px); 
        }

        #articles-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            position: relative;
        }

        /* Style to prevent body scrolling when articles are stacking */
        body.no-scroll {
            overflow: hidden;
        }

        /* Ensure main content has proper flow */
        #articles-main {
            flex: 1;
            padding-top: 10px;
            padding-bottom: 0;
        }

        /* Specific styles for article cards */
        .article-card-wrapper {
            background-color: white;
            border: 1px solid white;
            border-radius: 20px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            color: black;
        }

        .article-card-title {
            background-color: #CDEDA2;
            color: black;
            border: 1px solid black;
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
            font-weight: 600;
        }

        .article-card-date,
        .article-card-metadata {
            color: white;
            margin-bottom: 0.5rem;
            padding-left: 1rem;
            padding-right: 1rem;
        }

        .article-card-date {
            font-size: 0.875rem;
            font-style: italic;
        }

        .article-card-metadata {
            font-size: 0.95rem;
            font-weight: 500;
        }

        .article-card-snippet {
            color: black;
            font-size: 0.95rem;
            line-height: 1.5;
            margin-top: 0.75rem;
            margin-bottom: 1rem;
        }
    </style>
</head>

<body class="bg-primary-background-dark text-text-light min-h-screen flex flex-col">

    <nav id="site-navbar"
        class="navbar sticky top-0 w-full border border-black backdrop-blur bg-primary-background-dark bg-opacity-50 transform transition-transform duration-500 -translate-y-full z-50">
        <ul class="flex justify-around items-center py-4">
            <li><a href="index.html" class="flex flex-col items-center"><img src="../assets/Vector.svg"
                        alt="Home Icon"><span>HOME</span></a></li>
            <li><a href="about.html" class="flex flex-col items-center"><img src="../assets/About Icon.svg"
                        alt="About Icon"><span>ABOUT</span></a></li>
            <li><a href="projects.html" class="flex flex-col items-center"><img src="../assets/Projects Icon.svg"
                        alt="Projects Icon"><span>PROJECTS</span></a></li>
            <li><a href="articles.html" class="flex flex-col items-center"><img src="../assets/Articles Icon.svg"
                        alt="Articles Icon"><span>ARTICLES</span></a></li>
            <li><a href="hireMe.html" class="flex flex-col items-center"><img src="../assets/HireMe Icon.svg"
                        alt="Hire Me Icon"><span>HIRE ME</span></a></li>
            <li id="dark-toggle" class="flex flex-col items-center cursor-pointer"><img
                    src="../assets/ToggleOff Icon.svg" alt="Toggle Dark Mode" id="dark-toggle-icon"><span>theme</span></li>
        </ul>
    </nav>

    <main id="articles-main">
        <div class="container mx-auto px-4">

            <h2 class="text-xl font-bold pt-6 pl-4 text-text-light">Publications</h2>
            <div class="thin-line mt-3 mx-4"></div>

            <div id="articles-list" class="mt-4">

                <section class="article-item" data-article-id="ai-ethics">
                    <h3 class="article-card-title text-lg font-bold">The Ethical Implications of AI in Design</h3>
                    <p class="article-card-date">Published: May 15, 2025</p>
                    <p class="article-card-metadata">Author: Mubarak Afolabi | Category: AI, Ethics, Design</p>
                    <div class="article-card-wrapper">
                        <p class="article-card-snippet">
                            Exploring the critical ethical considerations designers face when integrating artificial
                            intelligence into their products and services. We delve into issues of bias, transparency,
                            and accountability.
                        </p>
                        <div class="w-full flex justify-center mt-auto">
                            <button class="btn-primary read-on-btn">Read On</button>
                        </div>
                    </div>
                </section>

                <section class="article-item" data-article-id="frontend-trends">
                    <h3 class="article-card-title text-lg font-bold">Frontend Frameworks: A Look at 2025 Trends</h3>
                    <p class="article-card-date">Published: April 28, 2025</p>
                    <p class="article-card-metadata">Author: Mubarak Afolabi | Category: Web Development, Frontend</p>
                    <div class="article-card-wrapper">
                        <p class="article-card-snippet">
                            A comprehensive overview of the most popular and emerging frontend frameworks in 2025,
                            discussing their strengths, weaknesses, and ideal use cases for modern web applications.
                        </p>
                        <div class="w-full flex justify-center mt-auto">
                            <button class="btn-primary read-on-btn">Read On</button>
                        </div>
                    </div>
                </section>

                <section class="article-item" data-article-id="ux-principles">
                    <h3 class="article-card-title text-lg font-bold">Mastering UX: Core Principles for Engaging
                        Interfaces</h3>
                    <p class="article-card-date">Published: March 10, 2025</p>
                    <p class="article-card-metadata">Author: Mubarak Afolabi | Category: UI/UX, Design</p>
                    <div class="article-card-wrapper">
                        <p class="article-card-snippet">
                            This article breaks down the fundamental principles of User Experience (UX) design,
                            offering practical tips and insights to create truly engaging and user-friendly digital
                            products.
                        </p>
                        <div class="w-full flex justify-center mt-auto">
                            <button class="btn-primary read-on-btn">Read On</button>
                        </div>
                    </div>
                </section>

            </div>
        </div>
    </main>

    <footer class="text-center text-text-muted bg-primary-background-dark py-4 z-40 mt-2">
        <span>© 2025 Mubarak Afolabi. All rights reserved.</span>
    </footer>

    <script>
        // === Navbar show/hide ===
        const nav = document.getElementById('site-navbar');
        let hideTimer;

        function showNavbar() {
            nav.classList.remove('-translate-y-full');
            clearTimeout(hideTimer);
            hideTimer = setTimeout(hideNavbar, 2500); // Changed to call hideNavbar directly
        }

        function hideNavbar() {
            nav.classList.add('-translate-y-full');
        }

        // 1) Show on scroll
        window.addEventListener('scroll', showNavbar);

        // 2) Show on page load
        document.addEventListener('DOMContentLoaded', showNavbar);

        // 3) Show when mouse hovers directly over the visible bar
        nav.addEventListener('mouseenter', showNavbar);

        // 4) Hide 2.5s after leaving the nav (re-setting the timer)
        nav.addEventListener('mouseleave', () => {
            clearTimeout(hideTimer);
            hideTimer = setTimeout(hideNavbar, 2500);
        });

        // 5) Show when cursor hits top 50px of viewport
        window.addEventListener('mousemove', (e) => {
            if (e.clientY < 50) showNavbar();
        });

        // === Dark mode toggle ===
        const toggleLi = document.getElementById('dark-toggle');
        const toggleIcon = document.getElementById('dark-toggle-icon');

        toggleLi.addEventListener('click', () => {
            const isDark = document.documentElement.classList.toggle('dark');
            toggleIcon.src = isDark ? '../assets/ToggleOn Icon.svg' : '../assets/ToggleOff Icon.svg';

            // Save theme preference to localStorage
            if (isDark) {
                localStorage.setItem('theme', 'dark');
            } else {
                localStorage.setItem('theme', 'light');
            }
        });

        // Initial check for dark mode on load
        document.addEventListener('DOMContentLoaded', () => {
            if (localStorage.getItem('theme') === 'dark') {
                document.documentElement.classList.add('dark');
                toggleIcon.src = '../assets/ToggleOn Icon.svg';
            } else {
                document.documentElement.classList.remove('dark');
                toggleIcon.src = '../assets/ToggleOff Icon.svg';
            }
        });


        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.read-on-btn').forEach(btn => btn.addEventListener('click', e => {
                e.preventDefault();
                const articleItem = e.target.closest('.article-item');
                if (articleItem) {
                    const articleId = articleItem.dataset.articleId;
                    window.location.href = `articleDetail.html?id=${articleId}`;
                } else {
                    console.error("Could not find parent .article-item for the clicked button.");
                    window.location.href = 'articleDetail.html'; // Fallback
                }
            }));
        });

        // === Article Card Stack Scroll Animation ===
        document.addEventListener('DOMContentLoaded', () => {
            const articlesList = document.getElementById('articles-list');
            const articleItems = articlesList.querySelectorAll('.article-item');
            const body = document.body;

            if (articleItems.length === 0) return;

            const articlesMain = document.getElementById('articles-main');
            let articlesListTop = articlesList.offsetTop + articlesMain.offsetTop; // Initial calculation

            let totalStackingHeight = 0;
            let firstCardHeight = 0;
            let cardGap = 0;

            const resizeObserver = new ResizeObserver(entries => {
                calculateStackingMetrics();
                onScroll(); // Recalculate and apply on scroll
            });


            function calculateStackingMetrics() {
                if (articleItems.length === 0) return;

                // Re-calculate articlesListTop as elements might shift
                articlesListTop = articlesList.offsetTop + articlesMain.offsetTop;

                const computedStyle = window.getComputedStyle(articlesList);
                cardGap = parseFloat(computedStyle.getPropertyValue('gap'));
                if (isNaN(cardGap)) {
                    cardGap = 0;
                    console.warn("Could not determine CSS gap for #articles-list. Stacking height might be inaccurate.");
                }

                firstCardHeight = articleItems[0].offsetHeight;
                let totalInitialHeight = 0;
                articleItems.forEach(item => {
                    totalInitialHeight += item.offsetHeight;
                });

                totalInitialHeight += (articleItems.length - 1) * cardGap;

                const viewportHeight = window.innerHeight;
                const extraScrollSpace = Math.max(0, viewportHeight - firstCardHeight);
                totalStackingHeight = totalInitialHeight - firstCardHeight + extraScrollSpace;

                body.style.paddingBottom = `${totalStackingHeight}px`;

                // Observe all article items to recalculate on their resize
                articleItems.forEach(item => {
                    resizeObserver.observe(item);
                });

                calculateInitialOffsets(); // Recalculate offsets on metrics change
                onScroll(); // Apply changes immediately
            }


            function onScroll() {
                const scrollY = window.scrollY;

                // Define the scroll range where the stacking animation occurs
                const animationZoneStart = articlesListTop;
                const animationZoneEnd = animationZoneStart + totalStackingHeight;

                const isAnimating = scrollY >= animationZoneStart && scrollY <= animationZoneEnd;

                if (isAnimating) {
                    // Lock scrolling to the animation zone
                    body.classList.add('no-scroll');
                    window.scrollTo(0, clamp(scrollY, animationZoneStart, animationZoneEnd));
                } else {
                    body.classList.remove('no-scroll');
                }

                // Calculate progress within the animation zone
                const animationProgress = clamp((scrollY - animationZoneStart) / totalStackingHeight, 0, 1);

                articleItems.forEach((currentItem, index) => {
                    if (index === 0) {
                        // The first card always stays on top and fully opaque within the animation zone
                        currentItem.style.zIndex = 100;
                        currentItem.style.opacity = 1;
                        return;
                    }

                    // Calculate the scroll points for each card's stacking
                    // Each card starts "stacking" when the previous one is fully engaged.
                    const previousItemOffset = initialOffsets[index - 1]; // Where the previous card was originally
                    const currentItemOffset = initialOffsets[index]; // Where this card was originally

                    // The scroll value where this card *starts* its "sticking"
                    const itemStickStartScroll = animationZoneStart + (previousItemOffset - initialOffsets[0]);
                    // The scroll value where this card *finishes* its "sticking" and the next one starts
                    const itemStickEndScroll = animationZoneStart + (currentItemOffset - initialOffsets[0]);

                    // Determine the progress for this specific item's transition
                    const itemProgress = clamp((scrollY - itemStickStartScroll) / (currentItem.offsetHeight + cardGap), 0, 1);


                    currentItem.style.zIndex = 10 + index; // Ensure higher cards have higher z-index

                    if (scrollY >= itemStickStartScroll) {
                        // When the scroll enters the stacking zone for this card
                        const offsetFromTop = (index * 20); // Adjust this value for how much each card peeks out

                        currentItem.style.transform = `translateY(${Math.max(0, scrollY - itemStickStartScroll)}px)`;

                        currentItem.style.opacity = 1;
                        if (index > 0) {
                             // Fade out the previous card as the current one comes into view
                            const fadeProgress = clamp((scrollY - itemStickStartScroll) / (currentItem.offsetHeight * 0.5), 0, 1);
                            articleItems[index - 1].style.opacity = `${1 - fadeProgress}`;
                        }
                    } else {
                        // Before the stacking zone for this card, ensure it's in its original position
                        currentItem.style.transform = `translateY(0)`;
                        currentItem.style.opacity = 1;
                    }

                    // Ensure the first card stays fully visible and on top always
                    if (index === 0) {
                        currentItem.style.opacity = 1;
                        currentItem.style.transform = `translateY(${scrollY > animationZoneStart ? scrollY - animationZoneStart : 0}px)`;
                    }
                });

                // Reset opacity and transform when scrolling outside the animation zone
                if (scrollY < animationZoneStart || scrollY > animationZoneEnd) {
                    articleItems.forEach((item, index) => {
                        item.style.opacity = 1;
                        item.style.transform = `translateY(0)`;
                        item.style.zIndex = 1; // Reset z-index
                    });
                    body.classList.remove('no-scroll');
                    body.style.paddingBottom = '0';
                }
            }


            function clamp(x, min, max) {
                return Math.min(Math.max(x, min), max);
            }

            let initialOffsets = [];
            function calculateInitialOffsets() {
                initialOffsets = Array.from(articleItems).map(item => item.offsetTop);
            }


            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => {
                    calculateInitialOffsets();
                    calculateStackingMetrics();
                }, 100); // Small delay to ensure all CSS is rendered
            });

            window.addEventListener('resize', () => {
                // Remove resize observer on all elements to prevent multiple recalculations
                articleItems.forEach(item => resizeObserver.unobserve(item));
                calculateInitialOffsets();
                calculateStackingMetrics();
            });

            window.addEventListener('scroll', onScroll);
        });
    </script>

</body>

</html>