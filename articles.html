<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title id="site-title-meta">Mubarak Afolabi — Articles</title>
    <link href="css/style.css" rel="stylesheet" />

    <script src="https://cdn.jsdelivr.net/npm/js-yaml-browser@4.1.0/dist/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="js/contentLoader.js"></script>
    <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>

    <style>
        /* Existing styles from projects page for navbar and general layout */
        #site-navbar ul li img {
            width: 32px;
            height: 32px;
        }

        #site-navbar ul li a {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-decoration: none;
            color: white;
            cursor: pointer;
        }

        .thin-line {
            height: 0.5px;
            background-color: rgba(255, 255, 255, 0.5);
        }

        /* Styles specific to articles for stacking effect */
        .article-item {
            position: sticky;
            top: 60px;
            /* Adjust this if your navbar height changes */
            z-index: 1;
            transition: opacity 0.3s ease-out;
            /* Added transition for smooth opacity change */
            /* min-height: calc(100vh - 60px); Removed, handled by calculated padding */
        }

        #articles-list {
            display: flex;
            flex-direction: column;
            /* Adjust this gap to control initial spacing between cards */
            gap: 1rem;
            /* Important for positioning context of sticky children */
            position: relative;
        }

        /* Style to prevent body scrolling when articles are stacking */
        body.no-scroll {
            overflow: hidden;
        }

        /* Ensure main content has proper flow */
        #articles-main {
            flex-1;
            padding-top: 10px;
            padding-bottom: 0;
        }

        /* Specific styles for article cards */
        .article-card-wrapper {
            background-color: white;
            border: 1px solid white;
            border-radius: 20px;
            /* equivalent to rounded-2xl */
            padding: 1.5rem;
            /* equivalent to p-6 */
            display: flex;
            flex-direction: column;
            color: black;
            /* Default text color for the white card */
        }

        .article-card-title {
            background-color: #CDEDA2;
            /* Specific hex color as requested */
            color: black;
            /* Title text is black as requested */
            border: 1px solid black;
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
            font-weight: 600;
            /* semi-bold */
        }

        .article-card-date,
        .article-card-metadata {
            color: white;
            /* These texts are white as requested */
            margin-bottom: 0.5rem;
            padding-left: 1rem;
            /* Add some padding to align with the title block visual */
            padding-right: 1rem;
        }

        .article-card-date {
            font-size: 0.875rem;
            /* text-sm */
            font-style: italic;
        }

        .article-card-metadata {
            font-size: 0.95rem;
            /* slightly larger than snippet */
            font-weight: 500;
            /* medium */
        }

        .article-card-snippet {
            color: black;
            /* Snippet text is black as it's on the white card */
            font-size: 0.95rem;
            /* text-sm */
            line-height: 1.5;
            margin-top: 0.75rem;
            /* Space between metadata and snippet */
            margin-bottom: 1rem;
        }
    </style>
</head>

<body class="bg-primary-background-dark text-text-light min-h-screen flex flex-col">

    <nav id="site-navbar"
        class="navbar sticky top-0 w-full border border-black backdrop-blur bg-primary-background-dark bg-opacity-50 transform transition-transform duration-500 -translate-y-full z-50">
        <ul class="flex justify-around items-center py-4">
            <li><a href="index.html" class="flex flex-col items-center"><img src="assets/Vector.svg"
                        alt="Home Icon"><span>HOME</span></a></li>
            <li><a href="about.html" class="flex flex-col items-center"><img src="assets/About Icon.svg"
                        alt="About Icon"><span>ABOUT</span></a></li>
            <li><a href="projects.html" class="flex flex-col items-center"><img src="assets/Projects Icon.svg"
                        alt="Projects Icon"><span>PROJECTS</span></a></li>
            <li><a href="articles.html" class="flex flex-col items-center"><img src="assets/Articles Icon.svg"
                        alt="Articles Icon"><span>ARTICLES</span></a></li>
            <li><a href="hireMe.html" class="flex flex-col items-center"><img src="assets/HireMe Icon.svg"
                        alt="Hire Me Icon"><span>HIRE ME</span></a></li>
           
            <li id="dark-toggle" class="flex flex-col items-center cursor-pointer"><img
                    src="assets/ToggleOff Icon.svg" alt="Toggle Dark Mode" id="dark-toggle-icon"><span>dark
                        mode</span></li>
        </ul>
    </nav>

    <main id="articles-main">
        <div class="container mx-auto px-4">

            <h2 class="text-xl font-bold pt-6 pl-4 text-text-light">Publications</h2>
            <div class="thin-line mt-3 mx-4"></div>

            <div id="articles-list" class="mt-4">
                <p class="text-center text-text-light">Loading articles...</p>
            </div>
        </div>
    </main>

    <footer class="text-center text-text-muted bg-primary-background-dark py-4 z-40 mt-2">
        <span id="footer-text">
            </span>
    </footer>

    <script>
        // === Navbar show/hide ===
        const nav = document.getElementById('site-navbar');
        let hideTimer;

        function showNavbar() {
            nav.classList.remove('-translate-y-full');
            clearTimeout(hideTimer);
            hideTimer = setTimeout(() => nav.classList.add('-translate-y-full'), 2500);
        }
        window.addEventListener('scroll', showNavbar);
        document.addEventListener('DOMContentLoaded', showNavbar);
        nav.addEventListener('mouseenter', showNavbar);
        nav.addEventListener('mouseleave', showNavbar);
        window.addEventListener('mousemove', e => {
            if (e.clientY < 50) showNavbar();
        });

        // === Dark mode toggle ===
        const toggleLi = document.getElementById('dark-toggle');
        const toggleIcon = document.getElementById('dark-toggle-icon');
        toggleLi.addEventListener('click', () => {
            const isDark = document.documentElement.classList.toggle('dark');
            toggleIcon.src = isDark ? 'assets/ToggleOn Icon.svg' : 'assets/ToggleOff Icon.svg';
        });
        if (document.documentElement.classList.contains('dark')) toggleIcon.src = 'assets/ToggleOn Icon.svg';


        // === Article List & Animation Loading ===
        document.addEventListener('DOMContentLoaded', async () => {
            const articlesList = document.getElementById('articles-list');
            const articlesMain = document.getElementById('articles-main');
            const body = document.body;

            // Update Site Title in <head>
            const siteTitleMeta = document.getElementById('site-title-meta');
            // Update Header Profile Photo
            const headerProfilePhoto = document.getElementById('profile-photo-header');
            // Update Footer Text
            const footerTextSpan = document.getElementById('footer-text');

            try {
                const siteSettings = await loadSiteSettings();
                if (siteTitleMeta) {
                    siteTitleMeta.textContent = siteSettings.siteTitle ? `${siteSettings.siteTitle} — Articles` : 'Mubarak Afolabi — Articles';
                }
                if (headerProfilePhoto) {
                    headerProfilePhoto.src = siteSettings.profilePhotoHeader || 'assets/profile.jpg';
                }
                if (footerTextSpan) {
                    footerTextSpan.textContent = siteSettings.footerText || '© 2025 Mubarak Afolabi. All rights reserved.';
                }

                const articles = await loadArticlesList(); // Load articles from CMS

                articlesList.innerHTML = ''; // Clear loading message

                if (articles.length === 0) {
                    articlesList.innerHTML = '<p class="text-center text-text-muted">No articles found.</p>';
                    return;
                }

                articles.sort((a, b) => new Date(b.date) - new Date(a.date)); // Sort by date, newest first

                articles.forEach(article => {
                    const articleHtml = `
                        <section class="article-item" data-article-slug="${article.slug}">
                            <h3 class="article-card-title text-lg font-bold">${article.title}</h3>
                            <p class="article-card-date">Published: ${new Date(article.date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                            <p class="article-card-metadata">Author: ${article.author || 'Mubarak Afolabi'} | Category: ${article.categories ? article.categories.join(', ') : 'Uncategorized'}</p>
                            <div class="article-card-wrapper">
                                <p class="article-card-snippet">
                                    ${article.description || 'No snippet available.'}
                                </p>
                                <div class="w-full flex justify-center mt-auto">
                                    <button class="btn-primary read-on-btn" data-slug="${article.slug}">Read On</button>
                                </div>
                            </div>
                        </section>
                    `;
                    articlesList.insertAdjacentHTML('beforeend', articleHtml);
                });

                // Add event listeners for "Read On" buttons after dynamic content is added
                document.querySelectorAll('.read-on-btn').forEach(btn => btn.addEventListener('click', e => {
                    e.preventDefault();
                    const articleSlug = e.target.dataset.slug; // Get slug from data attribute
                    window.location.href = `articleDetail.html?slug=${articleSlug}`; // Pass slug to detail page
                }));

                // Re-initialize animation after content is loaded
                initArticleStackingAnimation();

            } catch (error) {
                console.error("Failed to load articles or site settings:", error);
                articlesList.innerHTML = '<p class="text-center text-red-500">Failed to load articles. Please try again later.</p>';
            }

            let articleItems = articlesList.querySelectorAll('.article-item');
            if (articleItems.length === 0) return;

            let totalStackingHeight = 0;
            let firstCardHeight = 0;
            let cardGap = 0;
            let initialOffsets = []; // To store initial offsetTops of cards

            const resizeObserver = new ResizeObserver(entries => {
                calculateStackingMetrics();
                onScroll();
            });

            function calculateStackingMetrics() {
                articleItems = articlesList.querySelectorAll('.article-item'); // Re-query in case of changes
                if (articleItems.length === 0) {
                    body.style.paddingBottom = '0';
                    return;
                }

                const computedStyle = window.getComputedStyle(articlesList);
                cardGap = parseFloat(computedStyle.getPropertyValue('gap'));
                if (isNaN(cardGap)) {
                    cardGap = 0;
                    console.warn("Could not determine CSS gap for #articles-list. Stacking height might be inaccurate.");
                }

                firstCardHeight = articleItems[0].offsetHeight;
                let totalInitialHeight = 0;
                articleItems.forEach(item => {
                    totalInitialHeight += item.offsetHeight;
                });

                totalInitialHeight += (articleItems.length - 1) * cardGap;

                const viewportHeight = window.innerHeight;
                // The space needed for all cards to 'stack' and the last one to be fully visible at the top
                const requiredScrollHeight = (articleItems.length - 1) * (firstCardHeight + cardGap) + firstCardHeight;

                // Adjust totalStackingHeight based on actual scroll needed for each card to reach the top
                totalStackingHeight = 0;
                for (let i = 0; i < articleItems.length; i++) {
                    // For each card after the first, we need to scroll its height + gap to bring it to top
                    if (i > 0) {
                        totalStackingHeight += (articleItems[i-1].offsetHeight + cardGap);
                    }
                }
                 // Add extra space so the user can scroll to the bottom of the last article easily
                totalStackingHeight += viewportHeight * 0.7; // Example: Add 70% of viewport height


                body.style.paddingBottom = `${totalStackingHeight}px`;

                articleItems.forEach(item => {
                    resizeObserver.observe(item);
                });

                calculateInitialOffsets(); // Recalculate offsets on resize
                onScroll();
            }


            function onScroll() {
                const scrollY = window.scrollY;

                const animationZoneStart = articlesList.offsetTop + articlesMain.offsetTop;
                // Calculate animationZoneEnd based on the cumulative heights of cards + gaps
                let currentCumulativeHeight = 0;
                for(let i = 0; i < articleItems.length; i++) {
                    currentCumulativeHeight += articleItems[i].offsetHeight;
                    if (i < articleItems.length - 1) {
                        currentCumulativeHeight += cardGap;
                    }
                }
                // The end is when the last item is at the top of the viewport minus sticky offset (60px)
                const animationZoneEnd = animationZoneStart + currentCumulativeHeight - window.innerHeight + 60; // 60px is the top offset for sticky

                if (scrollY >= animationZoneStart && scrollY <= animationZoneEnd) {
                    body.classList.add('no-scroll');
                    window.scrollTo(0, clamp(scrollY, animationZoneStart, animationZoneEnd));
                } else {
                    body.classList.remove('no-scroll');
                }

                articleItems.forEach((currentItem, index) => {
                    const stickyOffset = 60; // The `top` value for sticky positioning

                    // Each card becomes visible and sticks as it reaches `stickyOffset` from the top
                    // The "trigger point" for a card to start sticking is its initial position minus the stickyOffset
                    const triggerPoint = initialOffsets[index] - stickyOffset;

                    // How far past its trigger point the scroll has gone
                    const scrollPastTrigger = scrollY - triggerPoint;

                    // When the previous item is at stickyOffset + its height, the current item should be fully visible
                    const nextCardTriggerPoint = (index + 1 < articleItems.length) ? (initialOffsets[index + 1] - stickyOffset) : (triggerPoint + firstCardHeight + cardGap);

                    // Fade out the current item when the next item is about to start sticking
                    let opacity = 1;
                    if (index < articleItems.length - 1) {
                        const nextItemTrigger = initialOffsets[index + 1] - stickyOffset;
                        if (scrollY > nextItemTrigger) {
                            // Current item should start fading out as the next one comes into view
                            const fadeStart = nextItemTrigger;
                            const fadeEnd = nextItemTrigger + (currentItem.offsetHeight * 0.5); // Fade over half its height
                            opacity = 1 - clamp((scrollY - fadeStart) / (fadeEnd - fadeStart), 0, 1);
                        }
                    }

                    currentItem.style.zIndex = 10 + index;
                    currentItem.style.opacity = opacity;

                    // Adjust `top` to keep it sticky at 60px when in its active range
                    if (scrollY > triggerPoint && scrollY < nextCardTriggerPoint) {
                        currentItem.style.top = `${stickyOffset}px`;
                    } else if (scrollY <= triggerPoint) {
                        currentItem.style.top = `${initialOffsets[index] - scrollY}px`; // Unstick when scrolling up past its initial position
                    } else {
                        // After it has been "scrolled past" by the next card taking its place
                        currentItem.style.top = `-${currentItem.offsetHeight + cardGap}px`; // Move it far up, or set display none.
                        currentItem.style.opacity = 0; // Ensure it's hidden
                    }
                });

                // When scrolling reaches the very end of the animation zone, release body scroll
                if (scrollY >= animationZoneEnd - 100) { // Small buffer before releasing
                    body.classList.remove('no-scroll');
                    body.style.paddingBottom = '0'; // Reset padding once animation is "done"
                } else if (scrollY < animationZoneStart) {
                    body.classList.remove('no-scroll');
                    body.style.paddingBottom = `${totalStackingHeight}px`; // Maintain padding before animation starts
                }
            }


            function clamp(x, min, max) {
                return Math.min(Math.max(x, min), max);
            }

            function calculateInitialOffsets() {
                articleItems = articlesList.querySelectorAll('.article-item'); // Refresh node list
                initialOffsets = Array.from(articleItems).map(item => item.offsetTop);
            }

            function initArticleStackingAnimation() {
                calculateInitialOffsets();
                calculateStackingMetrics();
                window.addEventListener('scroll', onScroll);
                window.addEventListener('resize', () => {
                    calculateInitialOffsets();
                    calculateStackingMetrics();
                });
                onScroll(); // Call once on load to set initial state
            }

            // Call initialization function after articles are loaded
            // (This call is now placed inside the DOMContentLoaded async block after articles are appended)
        });
    </script>
</body>

</html>